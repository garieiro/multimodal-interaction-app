{"ast":null,"code":"const transformDataToSankeyChart = data => {\n  const nodesSet = new Set(); // Usamos um Set para evitar duplicatas\n  const formattedLinks = [];\n\n  // Iterar sobre cada \"experiência\" no conjunto de dados\n  for (const experienceKey in data) {\n    const experience = data[experienceKey];\n\n    // Verificar se experience é um array\n    if (!Array.isArray(experience)) {\n      console.error(`Esperado um array, mas recebeu: ${typeof experience}`, experience);\n      continue; // Pula esta iteração se experience não for um array\n    }\n    for (const entry of experience) {\n      const source = entry.Source;\n      const target = entry.Target;\n      const duration = calculateDuration(entry.Start, entry.End); // Função para calcular a duração\n\n      // Adiciona os nós ao conjunto\n      nodesSet.add(source);\n      nodesSet.add(target);\n\n      // Formata os links\n      formattedLinks.push({\n        source: source,\n        target: target,\n        value: duration\n      });\n    }\n  }\n\n  // Converter o Set de nós para um array e mapear cada nó para o formato esperado\n  const nodesArray = Array.from(nodesSet).map(name => {\n    // Aqui definimos a categoria com base no nome do nó\n    const category = name.includes('MODALITY') ? 'INPUT' : 'OUTPUT'; // Defina a lógica conforme necessário\n    return {\n      name,\n      category\n    };\n  });\n\n  // Criar um índice de nós para que possamos mapear os índices corretamente nos links\n  const nodesIndex = Object.fromEntries(nodesArray.map((node, index) => [node.name, index]));\n\n  // Ajustar os links para usar os índices corretos\n  const adjustedLinks = formattedLinks.map(link => ({\n    source: nodesIndex[link.source],\n    target: nodesIndex[link.target],\n    value: link.value\n  }));\n  return {\n    nodes: nodesArray,\n    links: adjustedLinks\n  };\n};\n\n// Exemplo de uso\nconst sankeyData = transformDataToSankeyChart(data);\nconsole.log(sankeyData);","map":{"version":3,"names":["transformDataToSankeyChart","data","nodesSet","Set","formattedLinks","experienceKey","experience","Array","isArray","console","error","entry","source","Source","target","Target","duration","calculateDuration","Start","End","add","push","value","nodesArray","from","map","name","category","includes","nodesIndex","Object","fromEntries","node","index","adjustedLinks","link","nodes","links","sankeyData","log"],"sources":["/Users/goncaloarieiro/thesis/multimodal-interaction-app/src/components/charts/SankeyChart.js"],"sourcesContent":["const transformDataToSankeyChart = (data) => {\n  const nodesSet = new Set() // Usamos um Set para evitar duplicatas\n  const formattedLinks = []\n\n  // Iterar sobre cada \"experiência\" no conjunto de dados\n  for (const experienceKey in data) {\n    const experience = data[experienceKey]\n\n    // Verificar se experience é um array\n    if (!Array.isArray(experience)) {\n      console.error(\n        `Esperado um array, mas recebeu: ${typeof experience}`,\n        experience\n      )\n      continue // Pula esta iteração se experience não for um array\n    }\n\n    for (const entry of experience) {\n      const source = entry.Source\n      const target = entry.Target\n      const duration = calculateDuration(entry.Start, entry.End) // Função para calcular a duração\n\n      // Adiciona os nós ao conjunto\n      nodesSet.add(source)\n      nodesSet.add(target)\n\n      // Formata os links\n      formattedLinks.push({\n        source: source,\n        target: target,\n        value: duration,\n      })\n    }\n  }\n\n  // Converter o Set de nós para um array e mapear cada nó para o formato esperado\n  const nodesArray = Array.from(nodesSet).map((name) => {\n    // Aqui definimos a categoria com base no nome do nó\n    const category = name.includes('MODALITY') ? 'INPUT' : 'OUTPUT' // Defina a lógica conforme necessário\n    return { name, category }\n  })\n\n  // Criar um índice de nós para que possamos mapear os índices corretamente nos links\n  const nodesIndex = Object.fromEntries(\n    nodesArray.map((node, index) => [node.name, index])\n  )\n\n  // Ajustar os links para usar os índices corretos\n  const adjustedLinks = formattedLinks.map((link) => ({\n    source: nodesIndex[link.source],\n    target: nodesIndex[link.target],\n    value: link.value,\n  }))\n\n  return {\n    nodes: nodesArray,\n    links: adjustedLinks,\n  }\n}\n\n// Exemplo de uso\nconst sankeyData = transformDataToSankeyChart(data)\nconsole.log(sankeyData)\n"],"mappings":"AAAA,MAAMA,0BAA0B,GAAIC,IAAI,IAAK;EAC3C,MAAMC,QAAQ,GAAG,IAAIC,GAAG,CAAC,CAAC,EAAC;EAC3B,MAAMC,cAAc,GAAG,EAAE;;EAEzB;EACA,KAAK,MAAMC,aAAa,IAAIJ,IAAI,EAAE;IAChC,MAAMK,UAAU,GAAGL,IAAI,CAACI,aAAa,CAAC;;IAEtC;IACA,IAAI,CAACE,KAAK,CAACC,OAAO,CAACF,UAAU,CAAC,EAAE;MAC9BG,OAAO,CAACC,KAAK,CACX,mCAAmC,OAAOJ,UAAU,EAAE,EACtDA,UACF,CAAC;MACD,SAAQ,CAAC;IACX;IAEA,KAAK,MAAMK,KAAK,IAAIL,UAAU,EAAE;MAC9B,MAAMM,MAAM,GAAGD,KAAK,CAACE,MAAM;MAC3B,MAAMC,MAAM,GAAGH,KAAK,CAACI,MAAM;MAC3B,MAAMC,QAAQ,GAAGC,iBAAiB,CAACN,KAAK,CAACO,KAAK,EAAEP,KAAK,CAACQ,GAAG,CAAC,EAAC;;MAE3D;MACAjB,QAAQ,CAACkB,GAAG,CAACR,MAAM,CAAC;MACpBV,QAAQ,CAACkB,GAAG,CAACN,MAAM,CAAC;;MAEpB;MACAV,cAAc,CAACiB,IAAI,CAAC;QAClBT,MAAM,EAAEA,MAAM;QACdE,MAAM,EAAEA,MAAM;QACdQ,KAAK,EAAEN;MACT,CAAC,CAAC;IACJ;EACF;;EAEA;EACA,MAAMO,UAAU,GAAGhB,KAAK,CAACiB,IAAI,CAACtB,QAAQ,CAAC,CAACuB,GAAG,CAAEC,IAAI,IAAK;IACpD;IACA,MAAMC,QAAQ,GAAGD,IAAI,CAACE,QAAQ,CAAC,UAAU,CAAC,GAAG,OAAO,GAAG,QAAQ,EAAC;IAChE,OAAO;MAAEF,IAAI;MAAEC;IAAS,CAAC;EAC3B,CAAC,CAAC;;EAEF;EACA,MAAME,UAAU,GAAGC,MAAM,CAACC,WAAW,CACnCR,UAAU,CAACE,GAAG,CAAC,CAACO,IAAI,EAAEC,KAAK,KAAK,CAACD,IAAI,CAACN,IAAI,EAAEO,KAAK,CAAC,CACpD,CAAC;;EAED;EACA,MAAMC,aAAa,GAAG9B,cAAc,CAACqB,GAAG,CAAEU,IAAI,KAAM;IAClDvB,MAAM,EAAEiB,UAAU,CAACM,IAAI,CAACvB,MAAM,CAAC;IAC/BE,MAAM,EAAEe,UAAU,CAACM,IAAI,CAACrB,MAAM,CAAC;IAC/BQ,KAAK,EAAEa,IAAI,CAACb;EACd,CAAC,CAAC,CAAC;EAEH,OAAO;IACLc,KAAK,EAAEb,UAAU;IACjBc,KAAK,EAAEH;EACT,CAAC;AACH,CAAC;;AAED;AACA,MAAMI,UAAU,GAAGtC,0BAA0B,CAACC,IAAI,CAAC;AACnDQ,OAAO,CAAC8B,GAAG,CAACD,UAAU,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}