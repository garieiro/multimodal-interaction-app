{"ast":null,"code":"/**\n * @fileoverview Utility functions for AST\n */\n\n'use strict';\n\nconst estraverse = require('estraverse');\nconst eslintUtil = require('./eslint');\nconst getFirstTokens = eslintUtil.getFirstTokens;\nconst getScope = eslintUtil.getScope;\nconst getSourceCode = eslintUtil.getSourceCode;\n// const pragmaUtil = require('./pragma');\n\n/**\n * Wrapper for estraverse.traverse\n *\n * @param {ASTNode} ASTnode The AST node being checked\n * @param {Object} visitor Visitor Object for estraverse\n */\nfunction traverse(ASTnode, visitor) {\n  const opts = Object.assign({}, {\n    fallback(node) {\n      return Object.keys(node).filter(key => key === 'children' || key === 'argument');\n    }\n  }, visitor);\n  opts.keys = Object.assign({}, visitor.keys, {\n    JSXElement: ['children'],\n    JSXFragment: ['children']\n  });\n  estraverse.traverse(ASTnode, opts);\n}\nfunction loopNodes(nodes) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    if (nodes[i].type === 'ReturnStatement') {\n      return nodes[i];\n    }\n    if (nodes[i].type === 'SwitchStatement') {\n      const j = nodes[i].cases.length - 1;\n      if (j >= 0) {\n        return loopNodes(nodes[i].cases[j].consequent);\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Find a return statement in the current node\n *\n * @param {ASTNode} node The AST node being checked\n * @returns {ASTNode | false}\n */\nfunction findReturnStatement(node) {\n  if ((!node.value || !node.value.body || !node.value.body.body) && (!node.body || !node.body.body)) {\n    return false;\n  }\n  const bodyNodes = node.value ? node.value.body.body : node.body.body;\n  return loopNodes(bodyNodes);\n}\n\n// eslint-disable-next-line valid-jsdoc -- valid-jsdoc cannot parse function types.\n/**\n * Helper function for traversing \"returns\" (return statements or the\n * returned expression in the case of an arrow function) of a function\n *\n * @param {ASTNode} ASTNode The AST node being checked\n * @param {Context} context The context of `ASTNode`.\n * @param {(returnValue: ASTNode, breakTraverse: () => void) => void} onReturn\n *   Function to execute for each returnStatement found\n * @returns {undefined}\n */\nfunction traverseReturns(ASTNode, context, onReturn) {\n  const nodeType = ASTNode.type;\n  if (nodeType === 'ReturnStatement') {\n    onReturn(ASTNode.argument, () => {});\n    return;\n  }\n  if (nodeType === 'ArrowFunctionExpression' && ASTNode.expression) {\n    onReturn(ASTNode.body, () => {});\n    return;\n  }\n\n  /* TODO: properly warn on React.forwardRefs having typo properties\n  if (nodeType === 'CallExpression') {\n    const callee = ASTNode.callee;\n    const pragma = pragmaUtil.getFromContext(context);\n    if (\n      callee.type === 'MemberExpression'\n      && callee.object.type === 'Identifier'\n      && callee.object.name === pragma\n      && callee.property.type === 'Identifier'\n      && callee.property.name === 'forwardRef'\n      && ASTNode.arguments.length > 0\n    ) {\n      return enterFunc(ASTNode.arguments[0]);\n    }\n    return;\n  }\n  */\n\n  if (nodeType !== 'FunctionExpression' && nodeType !== 'FunctionDeclaration' && nodeType !== 'ArrowFunctionExpression' && nodeType !== 'MethodDefinition') {\n    return;\n  }\n  traverse(ASTNode.body, {\n    enter(node) {\n      const breakTraverse = () => {\n        this.break();\n      };\n      switch (node.type) {\n        case 'ReturnStatement':\n          this.skip();\n          onReturn(node.argument, breakTraverse);\n          return;\n        case 'BlockStatement':\n        case 'IfStatement':\n        case 'ForStatement':\n        case 'WhileStatement':\n        case 'SwitchStatement':\n        case 'SwitchCase':\n          return;\n        default:\n          this.skip();\n      }\n    }\n  });\n}\n\n/**\n * Get node with property's name\n * @param {Object} node - Property.\n * @returns {Object} Property name node.\n */\nfunction getPropertyNameNode(node) {\n  if (node.key || ['MethodDefinition', 'Property'].indexOf(node.type) !== -1) {\n    return node.key;\n  }\n  if (node.type === 'MemberExpression') {\n    return node.property;\n  }\n  return null;\n}\n\n/**\n * Get properties name\n * @param {Object} node - Property.\n * @returns {String} Property name.\n */\nfunction getPropertyName(node) {\n  const nameNode = getPropertyNameNode(node);\n  return nameNode ? nameNode.name : '';\n}\n\n/**\n * Get properties for a given AST node\n * @param {ASTNode} node The AST node being checked.\n * @returns {Array} Properties array.\n */\nfunction getComponentProperties(node) {\n  switch (node.type) {\n    case 'ClassDeclaration':\n    case 'ClassExpression':\n      return node.body.body;\n    case 'ObjectExpression':\n      return node.properties;\n    default:\n      return [];\n  }\n}\n\n/**\n * Gets the first node in a line from the initial node, excluding whitespace.\n * @param {Object} context The node to check\n * @param {ASTNode} node The node to check\n * @return {ASTNode} the first node in the line\n */\nfunction getFirstNodeInLine(context, node) {\n  const sourceCode = getSourceCode(context);\n  let token = node;\n  let lines;\n  do {\n    token = sourceCode.getTokenBefore(token);\n    lines = token.type === 'JSXText' ? token.value.split('\\n') : null;\n  } while (token.type === 'JSXText' && /^\\s*$/.test(lines[lines.length - 1]));\n  return token;\n}\n\n/**\n * Checks if the node is the first in its line, excluding whitespace.\n * @param {Object} context The node to check\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's the first node in its line\n */\nfunction isNodeFirstInLine(context, node) {\n  const token = getFirstNodeInLine(context, node);\n  const startLine = node.loc.start.line;\n  const endLine = token ? token.loc.end.line : -1;\n  return startLine !== endLine;\n}\n\n/**\n * Checks if the node is a function or arrow function expression.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a function-like expression\n */\nfunction isFunctionLikeExpression(node) {\n  return node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression';\n}\n\n/**\n * Checks if the node is a function.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a function\n */\nfunction isFunction(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\n}\n\n/**\n * Checks if node is a function declaration or expression or arrow function.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a function-like\n */\nfunction isFunctionLike(node) {\n  return node.type === 'FunctionDeclaration' || isFunctionLikeExpression(node);\n}\n\n/**\n * Checks if the node is a class.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a class\n */\nfunction isClass(node) {\n  return node.type === 'ClassDeclaration' || node.type === 'ClassExpression';\n}\n\n/**\n * Check if we are in a class constructor\n * @param {Context} context\n * @param {ASTNode} node The AST node being checked.\n * @return {boolean}\n */\nfunction inConstructor(context, node) {\n  let scope = getScope(context, node);\n  while (scope) {\n    // @ts-ignore\n    if (scope.block && scope.block.parent && scope.block.parent.kind === 'constructor') {\n      return true;\n    }\n    scope = scope.upper;\n  }\n  return false;\n}\n\n/**\n * Removes quotes from around an identifier.\n * @param {string} string the identifier to strip\n * @returns {string}\n */\nfunction stripQuotes(string) {\n  return string.replace(/^'|'$/g, '');\n}\n\n/**\n * Retrieve the name of a key node\n * @param {Context} context The AST node with the key.\n * @param {any} node The AST node with the key.\n * @return {string | undefined} the name of the key\n */\nfunction getKeyValue(context, node) {\n  if (node.type === 'ObjectTypeProperty') {\n    const tokens = getFirstTokens(context, node, 2);\n    return tokens[0].value === '+' || tokens[0].value === '-' ? tokens[1].value : stripQuotes(tokens[0].value);\n  }\n  if (node.type === 'GenericTypeAnnotation') {\n    return node.id.name;\n  }\n  if (node.type === 'ObjectTypeAnnotation') {\n    return;\n  }\n  const key = node.key || node.argument;\n  if (!key) {\n    return;\n  }\n  return key.type === 'Identifier' ? key.name : key.value;\n}\n\n/**\n * Checks if a node is surrounded by parenthesis.\n *\n * @param {object} context - Context from the rule\n * @param {ASTNode} node - Node to be checked\n * @returns {boolean}\n */\nfunction isParenthesized(context, node) {\n  const sourceCode = getSourceCode(context);\n  const previousToken = sourceCode.getTokenBefore(node);\n  const nextToken = sourceCode.getTokenAfter(node);\n  return !!previousToken && !!nextToken && previousToken.value === '(' && previousToken.range[1] <= node.range[0] && nextToken.value === ')' && nextToken.range[0] >= node.range[1];\n}\n\n/**\n * Checks if a node is being assigned a value: props.bar = 'bar'\n * @param {ASTNode} node The AST node being checked.\n * @returns {Boolean}\n */\nfunction isAssignmentLHS(node) {\n  return node.parent && node.parent.type === 'AssignmentExpression' && node.parent.left === node;\n}\n\n/**\n * Extracts the expression node that is wrapped inside a TS type assertion\n *\n * @param {ASTNode} node - potential TS node\n * @returns {ASTNode} - unwrapped expression node\n */\nfunction unwrapTSAsExpression(node) {\n  if (node && node.type === 'TSAsExpression') return node.expression;\n  return node;\n}\nfunction isTSTypeReference(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeReference';\n}\nfunction isTSTypeAnnotation(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeAnnotation';\n}\nfunction isTSTypeLiteral(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeLiteral';\n}\nfunction isTSIntersectionType(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSIntersectionType';\n}\nfunction isTSInterfaceHeritage(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSInterfaceHeritage';\n}\nfunction isTSInterfaceDeclaration(node) {\n  if (!node) return false;\n  let nodeType = node.type;\n  if (node.type === 'ExportNamedDeclaration' && node.declaration) {\n    nodeType = node.declaration.type;\n  }\n  return nodeType === 'TSInterfaceDeclaration';\n}\nfunction isTSTypeDeclaration(node) {\n  if (!node) return false;\n  let nodeType = node.type;\n  let nodeKind = node.kind;\n  if (node.type === 'ExportNamedDeclaration' && node.declaration) {\n    nodeType = node.declaration.type;\n    nodeKind = node.declaration.kind;\n  }\n  return nodeType === 'VariableDeclaration' && nodeKind === 'type';\n}\nfunction isTSTypeAliasDeclaration(node) {\n  if (!node) return false;\n  let nodeType = node.type;\n  if (node.type === 'ExportNamedDeclaration' && node.declaration) {\n    nodeType = node.declaration.type;\n    return nodeType === 'TSTypeAliasDeclaration' && node.exportKind === 'type';\n  }\n  return nodeType === 'TSTypeAliasDeclaration';\n}\nfunction isTSParenthesizedType(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeAliasDeclaration';\n}\nfunction isTSFunctionType(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSFunctionType';\n}\nfunction isTSTypeQuery(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeQuery';\n}\nfunction isTSTypeParameterInstantiation(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeParameterInstantiation';\n}\nmodule.exports = {\n  traverse,\n  findReturnStatement,\n  getFirstNodeInLine,\n  getPropertyName,\n  getPropertyNameNode,\n  getComponentProperties,\n  getKeyValue,\n  isParenthesized,\n  isAssignmentLHS,\n  isClass,\n  isFunction,\n  isFunctionLikeExpression,\n  isFunctionLike,\n  inConstructor,\n  isNodeFirstInLine,\n  unwrapTSAsExpression,\n  traverseReturns,\n  isTSTypeReference,\n  isTSTypeAnnotation,\n  isTSTypeLiteral,\n  isTSIntersectionType,\n  isTSInterfaceHeritage,\n  isTSInterfaceDeclaration,\n  isTSTypeAliasDeclaration,\n  isTSParenthesizedType,\n  isTSFunctionType,\n  isTSTypeQuery,\n  isTSTypeParameterInstantiation,\n  isTSTypeDeclaration\n};","map":{"version":3,"names":["estraverse","require","eslintUtil","getFirstTokens","getScope","getSourceCode","traverse","ASTnode","visitor","opts","Object","assign","fallback","node","keys","filter","key","JSXElement","JSXFragment","loopNodes","nodes","i","length","type","j","cases","consequent","findReturnStatement","value","body","bodyNodes","traverseReturns","ASTNode","context","onReturn","nodeType","argument","expression","enter","breakTraverse","break","skip","getPropertyNameNode","indexOf","property","getPropertyName","nameNode","name","getComponentProperties","properties","getFirstNodeInLine","sourceCode","token","lines","getTokenBefore","split","test","isNodeFirstInLine","startLine","loc","start","line","endLine","end","isFunctionLikeExpression","isFunction","isFunctionLike","isClass","inConstructor","scope","block","parent","kind","upper","stripQuotes","string","replace","getKeyValue","tokens","id","isParenthesized","previousToken","nextToken","getTokenAfter","range","isAssignmentLHS","left","unwrapTSAsExpression","isTSTypeReference","isTSTypeAnnotation","isTSTypeLiteral","isTSIntersectionType","isTSInterfaceHeritage","isTSInterfaceDeclaration","declaration","isTSTypeDeclaration","nodeKind","isTSTypeAliasDeclaration","exportKind","isTSParenthesizedType","isTSFunctionType","isTSTypeQuery","isTSTypeParameterInstantiation","module","exports"],"sources":["/Users/goncaloarieiro/thesis/multimodal-interaction-app/node_modules/eslint-plugin-react/lib/util/ast.js"],"sourcesContent":["/**\n * @fileoverview Utility functions for AST\n */\n\n'use strict';\n\nconst estraverse = require('estraverse');\nconst eslintUtil = require('./eslint');\n\nconst getFirstTokens = eslintUtil.getFirstTokens;\nconst getScope = eslintUtil.getScope;\nconst getSourceCode = eslintUtil.getSourceCode;\n// const pragmaUtil = require('./pragma');\n\n/**\n * Wrapper for estraverse.traverse\n *\n * @param {ASTNode} ASTnode The AST node being checked\n * @param {Object} visitor Visitor Object for estraverse\n */\nfunction traverse(ASTnode, visitor) {\n  const opts = Object.assign({}, {\n    fallback(node) {\n      return Object.keys(node).filter((key) => key === 'children' || key === 'argument');\n    },\n  }, visitor);\n\n  opts.keys = Object.assign({}, visitor.keys, {\n    JSXElement: ['children'],\n    JSXFragment: ['children'],\n  });\n\n  estraverse.traverse(ASTnode, opts);\n}\n\nfunction loopNodes(nodes) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    if (nodes[i].type === 'ReturnStatement') {\n      return nodes[i];\n    }\n    if (nodes[i].type === 'SwitchStatement') {\n      const j = nodes[i].cases.length - 1;\n      if (j >= 0) {\n        return loopNodes(nodes[i].cases[j].consequent);\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Find a return statement in the current node\n *\n * @param {ASTNode} node The AST node being checked\n * @returns {ASTNode | false}\n */\nfunction findReturnStatement(node) {\n  if (\n    (!node.value || !node.value.body || !node.value.body.body)\n    && (!node.body || !node.body.body)\n  ) {\n    return false;\n  }\n\n  const bodyNodes = node.value ? node.value.body.body : node.body.body;\n\n  return loopNodes(bodyNodes);\n}\n\n// eslint-disable-next-line valid-jsdoc -- valid-jsdoc cannot parse function types.\n/**\n * Helper function for traversing \"returns\" (return statements or the\n * returned expression in the case of an arrow function) of a function\n *\n * @param {ASTNode} ASTNode The AST node being checked\n * @param {Context} context The context of `ASTNode`.\n * @param {(returnValue: ASTNode, breakTraverse: () => void) => void} onReturn\n *   Function to execute for each returnStatement found\n * @returns {undefined}\n */\nfunction traverseReturns(ASTNode, context, onReturn) {\n  const nodeType = ASTNode.type;\n\n  if (nodeType === 'ReturnStatement') {\n    onReturn(ASTNode.argument, () => {});\n    return;\n  }\n\n  if (nodeType === 'ArrowFunctionExpression' && ASTNode.expression) {\n    onReturn(ASTNode.body, () => {});\n    return;\n  }\n\n  /* TODO: properly warn on React.forwardRefs having typo properties\n  if (nodeType === 'CallExpression') {\n    const callee = ASTNode.callee;\n    const pragma = pragmaUtil.getFromContext(context);\n    if (\n      callee.type === 'MemberExpression'\n      && callee.object.type === 'Identifier'\n      && callee.object.name === pragma\n      && callee.property.type === 'Identifier'\n      && callee.property.name === 'forwardRef'\n      && ASTNode.arguments.length > 0\n    ) {\n      return enterFunc(ASTNode.arguments[0]);\n    }\n    return;\n  }\n  */\n\n  if (\n    nodeType !== 'FunctionExpression'\n    && nodeType !== 'FunctionDeclaration'\n    && nodeType !== 'ArrowFunctionExpression'\n    && nodeType !== 'MethodDefinition'\n  ) {\n    return;\n  }\n\n  traverse(ASTNode.body, {\n    enter(node) {\n      const breakTraverse = () => {\n        this.break();\n      };\n      switch (node.type) {\n        case 'ReturnStatement':\n          this.skip();\n          onReturn(node.argument, breakTraverse);\n          return;\n        case 'BlockStatement':\n        case 'IfStatement':\n        case 'ForStatement':\n        case 'WhileStatement':\n        case 'SwitchStatement':\n        case 'SwitchCase':\n          return;\n        default:\n          this.skip();\n      }\n    },\n  });\n}\n\n/**\n * Get node with property's name\n * @param {Object} node - Property.\n * @returns {Object} Property name node.\n */\nfunction getPropertyNameNode(node) {\n  if (node.key || ['MethodDefinition', 'Property'].indexOf(node.type) !== -1) {\n    return node.key;\n  }\n  if (node.type === 'MemberExpression') {\n    return node.property;\n  }\n  return null;\n}\n\n/**\n * Get properties name\n * @param {Object} node - Property.\n * @returns {String} Property name.\n */\nfunction getPropertyName(node) {\n  const nameNode = getPropertyNameNode(node);\n  return nameNode ? nameNode.name : '';\n}\n\n/**\n * Get properties for a given AST node\n * @param {ASTNode} node The AST node being checked.\n * @returns {Array} Properties array.\n */\nfunction getComponentProperties(node) {\n  switch (node.type) {\n    case 'ClassDeclaration':\n    case 'ClassExpression':\n      return node.body.body;\n    case 'ObjectExpression':\n      return node.properties;\n    default:\n      return [];\n  }\n}\n\n/**\n * Gets the first node in a line from the initial node, excluding whitespace.\n * @param {Object} context The node to check\n * @param {ASTNode} node The node to check\n * @return {ASTNode} the first node in the line\n */\nfunction getFirstNodeInLine(context, node) {\n  const sourceCode = getSourceCode(context);\n  let token = node;\n  let lines;\n  do {\n    token = sourceCode.getTokenBefore(token);\n    lines = token.type === 'JSXText'\n      ? token.value.split('\\n')\n      : null;\n  } while (\n    token.type === 'JSXText'\n        && /^\\s*$/.test(lines[lines.length - 1])\n  );\n  return token;\n}\n\n/**\n * Checks if the node is the first in its line, excluding whitespace.\n * @param {Object} context The node to check\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's the first node in its line\n */\nfunction isNodeFirstInLine(context, node) {\n  const token = getFirstNodeInLine(context, node);\n  const startLine = node.loc.start.line;\n  const endLine = token ? token.loc.end.line : -1;\n  return startLine !== endLine;\n}\n\n/**\n * Checks if the node is a function or arrow function expression.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a function-like expression\n */\nfunction isFunctionLikeExpression(node) {\n  return node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression';\n}\n\n/**\n * Checks if the node is a function.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a function\n */\nfunction isFunction(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\n}\n\n/**\n * Checks if node is a function declaration or expression or arrow function.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a function-like\n */\nfunction isFunctionLike(node) {\n  return node.type === 'FunctionDeclaration' || isFunctionLikeExpression(node);\n}\n\n/**\n * Checks if the node is a class.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a class\n */\nfunction isClass(node) {\n  return node.type === 'ClassDeclaration' || node.type === 'ClassExpression';\n}\n\n/**\n * Check if we are in a class constructor\n * @param {Context} context\n * @param {ASTNode} node The AST node being checked.\n * @return {boolean}\n */\nfunction inConstructor(context, node) {\n  let scope = getScope(context, node);\n  while (scope) {\n    // @ts-ignore\n    if (scope.block && scope.block.parent && scope.block.parent.kind === 'constructor') {\n      return true;\n    }\n    scope = scope.upper;\n  }\n  return false;\n}\n\n/**\n * Removes quotes from around an identifier.\n * @param {string} string the identifier to strip\n * @returns {string}\n */\nfunction stripQuotes(string) {\n  return string.replace(/^'|'$/g, '');\n}\n\n/**\n * Retrieve the name of a key node\n * @param {Context} context The AST node with the key.\n * @param {any} node The AST node with the key.\n * @return {string | undefined} the name of the key\n */\nfunction getKeyValue(context, node) {\n  if (node.type === 'ObjectTypeProperty') {\n    const tokens = getFirstTokens(context, node, 2);\n    return (tokens[0].value === '+' || tokens[0].value === '-'\n      ? tokens[1].value\n      : stripQuotes(tokens[0].value)\n    );\n  }\n  if (node.type === 'GenericTypeAnnotation') {\n    return node.id.name;\n  }\n  if (node.type === 'ObjectTypeAnnotation') {\n    return;\n  }\n  const key = node.key || node.argument;\n  if (!key) {\n    return;\n  }\n  return key.type === 'Identifier' ? key.name : key.value;\n}\n\n/**\n * Checks if a node is surrounded by parenthesis.\n *\n * @param {object} context - Context from the rule\n * @param {ASTNode} node - Node to be checked\n * @returns {boolean}\n */\nfunction isParenthesized(context, node) {\n  const sourceCode = getSourceCode(context);\n  const previousToken = sourceCode.getTokenBefore(node);\n  const nextToken = sourceCode.getTokenAfter(node);\n\n  return !!previousToken && !!nextToken\n    && previousToken.value === '(' && previousToken.range[1] <= node.range[0]\n    && nextToken.value === ')' && nextToken.range[0] >= node.range[1];\n}\n\n/**\n * Checks if a node is being assigned a value: props.bar = 'bar'\n * @param {ASTNode} node The AST node being checked.\n * @returns {Boolean}\n */\nfunction isAssignmentLHS(node) {\n  return (\n    node.parent\n    && node.parent.type === 'AssignmentExpression'\n    && node.parent.left === node\n  );\n}\n\n/**\n * Extracts the expression node that is wrapped inside a TS type assertion\n *\n * @param {ASTNode} node - potential TS node\n * @returns {ASTNode} - unwrapped expression node\n */\nfunction unwrapTSAsExpression(node) {\n  if (node && node.type === 'TSAsExpression') return node.expression;\n  return node;\n}\n\nfunction isTSTypeReference(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeReference';\n}\n\nfunction isTSTypeAnnotation(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeAnnotation';\n}\n\nfunction isTSTypeLiteral(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeLiteral';\n}\n\nfunction isTSIntersectionType(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSIntersectionType';\n}\n\nfunction isTSInterfaceHeritage(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSInterfaceHeritage';\n}\n\nfunction isTSInterfaceDeclaration(node) {\n  if (!node) return false;\n  let nodeType = node.type;\n  if (node.type === 'ExportNamedDeclaration' && node.declaration) {\n    nodeType = node.declaration.type;\n  }\n  return nodeType === 'TSInterfaceDeclaration';\n}\n\nfunction isTSTypeDeclaration(node) {\n  if (!node) return false;\n  let nodeType = node.type;\n  let nodeKind = node.kind;\n  if (node.type === 'ExportNamedDeclaration' && node.declaration) {\n    nodeType = node.declaration.type;\n    nodeKind = node.declaration.kind;\n  }\n  return nodeType === 'VariableDeclaration' && nodeKind === 'type';\n}\n\nfunction isTSTypeAliasDeclaration(node) {\n  if (!node) return false;\n  let nodeType = node.type;\n  if (node.type === 'ExportNamedDeclaration' && node.declaration) {\n    nodeType = node.declaration.type;\n    return nodeType === 'TSTypeAliasDeclaration' && node.exportKind === 'type';\n  }\n  return nodeType === 'TSTypeAliasDeclaration';\n}\n\nfunction isTSParenthesizedType(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeAliasDeclaration';\n}\n\nfunction isTSFunctionType(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSFunctionType';\n}\n\nfunction isTSTypeQuery(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeQuery';\n}\n\nfunction isTSTypeParameterInstantiation(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeParameterInstantiation';\n}\n\nmodule.exports = {\n  traverse,\n  findReturnStatement,\n  getFirstNodeInLine,\n  getPropertyName,\n  getPropertyNameNode,\n  getComponentProperties,\n  getKeyValue,\n  isParenthesized,\n  isAssignmentLHS,\n  isClass,\n  isFunction,\n  isFunctionLikeExpression,\n  isFunctionLike,\n  inConstructor,\n  isNodeFirstInLine,\n  unwrapTSAsExpression,\n  traverseReturns,\n  isTSTypeReference,\n  isTSTypeAnnotation,\n  isTSTypeLiteral,\n  isTSIntersectionType,\n  isTSInterfaceHeritage,\n  isTSInterfaceDeclaration,\n  isTSTypeAliasDeclaration,\n  isTSParenthesizedType,\n  isTSFunctionType,\n  isTSTypeQuery,\n  isTSTypeParameterInstantiation,\n  isTSTypeDeclaration,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}