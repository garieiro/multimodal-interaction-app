{"ast":null,"code":"/**\n * @fileoverview Utility functions for JSX\n */\n\n'use strict';\n\nconst elementType = require('jsx-ast-utils/elementType');\nconst astUtil = require('./ast');\nconst isCreateElement = require('./isCreateElement');\nconst variableUtil = require('./variable');\n\n// See https://github.com/babel/babel/blob/ce420ba51c68591e057696ef43e028f41c6e04cd/packages/babel-types/src/validators/react/isCompatTag.js\n// for why we only test for the first character\nconst COMPAT_TAG_REGEX = /^[a-z]/;\n\n/**\n * Checks if a node represents a DOM element according to React.\n * @param {object} node - JSXOpeningElement to check.\n * @returns {boolean} Whether or not the node corresponds to a DOM element.\n */\nfunction isDOMComponent(node) {\n  const name = elementType(node);\n  return COMPAT_TAG_REGEX.test(name);\n}\n\n/**\n * Test whether a JSXElement is a fragment\n * @param {JSXElement} node\n * @param {string} reactPragma\n * @param {string} fragmentPragma\n * @returns {boolean}\n */\nfunction isFragment(node, reactPragma, fragmentPragma) {\n  const name = node.openingElement.name;\n\n  // <Fragment>\n  if (name.type === 'JSXIdentifier' && name.name === fragmentPragma) {\n    return true;\n  }\n\n  // <React.Fragment>\n  if (name.type === 'JSXMemberExpression' && name.object.type === 'JSXIdentifier' && name.object.name === reactPragma && name.property.type === 'JSXIdentifier' && name.property.name === fragmentPragma) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Checks if a node represents a JSX element or fragment.\n * @param {object} node - node to check.\n * @returns {boolean} Whether or not the node if a JSX element or fragment.\n */\nfunction isJSX(node) {\n  return node && ['JSXElement', 'JSXFragment'].indexOf(node.type) >= 0;\n}\n\n/**\n * Check if node is like `key={...}` as in `<Foo key={...} />`\n * @param {ASTNode} node\n * @returns {boolean}\n */\nfunction isJSXAttributeKey(node) {\n  return node.type === 'JSXAttribute' && node.name && node.name.type === 'JSXIdentifier' && node.name.name === 'key';\n}\n\n/**\n * Check if value has only whitespaces\n * @param {string} value\n * @returns {boolean}\n */\nfunction isWhiteSpaces(value) {\n  return typeof value === 'string' ? /^\\s*$/.test(value) : false;\n}\n\n/**\n * Check if the node is returning JSX or null\n *\n * @param {Context} context The context of `ASTNode`.\n * @param {ASTNode} ASTnode The AST node being checked\n * @param {Boolean} [strict] If true, in a ternary condition the node must return JSX in both cases\n * @param {Boolean} [ignoreNull] If true, null return values will be ignored\n * @returns {Boolean} True if the node is returning JSX or null, false if not\n */\nfunction isReturningJSX(context, ASTnode, strict, ignoreNull) {\n  const isJSXValue = node => {\n    if (!node) {\n      return false;\n    }\n    switch (node.type) {\n      case 'ConditionalExpression':\n        if (strict) {\n          return isJSXValue(node.consequent) && isJSXValue(node.alternate);\n        }\n        return isJSXValue(node.consequent) || isJSXValue(node.alternate);\n      case 'LogicalExpression':\n        if (strict) {\n          return isJSXValue(node.left) && isJSXValue(node.right);\n        }\n        return isJSXValue(node.left) || isJSXValue(node.right);\n      case 'SequenceExpression':\n        return isJSXValue(node.expressions[node.expressions.length - 1]);\n      case 'JSXElement':\n      case 'JSXFragment':\n        return true;\n      case 'CallExpression':\n        return isCreateElement(context, node);\n      case 'Literal':\n        if (!ignoreNull && node.value === null) {\n          return true;\n        }\n        return false;\n      case 'Identifier':\n        {\n          const variable = variableUtil.findVariableByName(context, node, node.name);\n          return isJSX(variable);\n        }\n      default:\n        return false;\n    }\n  };\n  let found = false;\n  astUtil.traverseReturns(ASTnode, context, (node, breakTraverse) => {\n    if (isJSXValue(node)) {\n      found = true;\n      breakTraverse();\n    }\n  });\n  return found;\n}\n\n/**\n * Check if the node is returning only null values\n *\n * @param {ASTNode} ASTnode The AST node being checked\n * @param {Context} context The context of `ASTNode`.\n * @returns {Boolean} True if the node is returning only null values\n */\nfunction isReturningOnlyNull(ASTnode, context) {\n  let found = false;\n  let foundSomethingElse = false;\n  astUtil.traverseReturns(ASTnode, context, node => {\n    // Traverse return statement\n    astUtil.traverse(node, {\n      enter(childNode) {\n        const setFound = () => {\n          found = true;\n          this.skip();\n        };\n        const setFoundSomethingElse = () => {\n          foundSomethingElse = true;\n          this.skip();\n        };\n        switch (childNode.type) {\n          case 'ReturnStatement':\n            break;\n          case 'ConditionalExpression':\n            if (childNode.consequent.value === null && childNode.alternate.value === null) {\n              setFound();\n            }\n            break;\n          case 'Literal':\n            if (childNode.value === null) {\n              setFound();\n            }\n            break;\n          default:\n            setFoundSomethingElse();\n        }\n      }\n    });\n  });\n  return found && !foundSomethingElse;\n}\nmodule.exports = {\n  isDOMComponent,\n  isFragment,\n  isJSX,\n  isJSXAttributeKey,\n  isWhiteSpaces,\n  isReturningJSX,\n  isReturningOnlyNull\n};","map":{"version":3,"names":["elementType","require","astUtil","isCreateElement","variableUtil","COMPAT_TAG_REGEX","isDOMComponent","node","name","test","isFragment","reactPragma","fragmentPragma","openingElement","type","object","property","isJSX","indexOf","isJSXAttributeKey","isWhiteSpaces","value","isReturningJSX","context","ASTnode","strict","ignoreNull","isJSXValue","consequent","alternate","left","right","expressions","length","variable","findVariableByName","found","traverseReturns","breakTraverse","isReturningOnlyNull","foundSomethingElse","traverse","enter","childNode","setFound","skip","setFoundSomethingElse","module","exports"],"sources":["/Users/goncaloarieiro/thesis/multimodal-interaction-app/node_modules/eslint-plugin-react/lib/util/jsx.js"],"sourcesContent":["/**\n * @fileoverview Utility functions for JSX\n */\n\n'use strict';\n\nconst elementType = require('jsx-ast-utils/elementType');\n\nconst astUtil = require('./ast');\nconst isCreateElement = require('./isCreateElement');\nconst variableUtil = require('./variable');\n\n// See https://github.com/babel/babel/blob/ce420ba51c68591e057696ef43e028f41c6e04cd/packages/babel-types/src/validators/react/isCompatTag.js\n// for why we only test for the first character\nconst COMPAT_TAG_REGEX = /^[a-z]/;\n\n/**\n * Checks if a node represents a DOM element according to React.\n * @param {object} node - JSXOpeningElement to check.\n * @returns {boolean} Whether or not the node corresponds to a DOM element.\n */\nfunction isDOMComponent(node) {\n  const name = elementType(node);\n  return COMPAT_TAG_REGEX.test(name);\n}\n\n/**\n * Test whether a JSXElement is a fragment\n * @param {JSXElement} node\n * @param {string} reactPragma\n * @param {string} fragmentPragma\n * @returns {boolean}\n */\nfunction isFragment(node, reactPragma, fragmentPragma) {\n  const name = node.openingElement.name;\n\n  // <Fragment>\n  if (name.type === 'JSXIdentifier' && name.name === fragmentPragma) {\n    return true;\n  }\n\n  // <React.Fragment>\n  if (\n    name.type === 'JSXMemberExpression'\n    && name.object.type === 'JSXIdentifier'\n    && name.object.name === reactPragma\n    && name.property.type === 'JSXIdentifier'\n    && name.property.name === fragmentPragma\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Checks if a node represents a JSX element or fragment.\n * @param {object} node - node to check.\n * @returns {boolean} Whether or not the node if a JSX element or fragment.\n */\nfunction isJSX(node) {\n  return node && ['JSXElement', 'JSXFragment'].indexOf(node.type) >= 0;\n}\n\n/**\n * Check if node is like `key={...}` as in `<Foo key={...} />`\n * @param {ASTNode} node\n * @returns {boolean}\n */\nfunction isJSXAttributeKey(node) {\n  return node.type === 'JSXAttribute'\n    && node.name\n    && node.name.type === 'JSXIdentifier'\n    && node.name.name === 'key';\n}\n\n/**\n * Check if value has only whitespaces\n * @param {string} value\n * @returns {boolean}\n */\nfunction isWhiteSpaces(value) {\n  return typeof value === 'string' ? /^\\s*$/.test(value) : false;\n}\n\n/**\n * Check if the node is returning JSX or null\n *\n * @param {Context} context The context of `ASTNode`.\n * @param {ASTNode} ASTnode The AST node being checked\n * @param {Boolean} [strict] If true, in a ternary condition the node must return JSX in both cases\n * @param {Boolean} [ignoreNull] If true, null return values will be ignored\n * @returns {Boolean} True if the node is returning JSX or null, false if not\n */\nfunction isReturningJSX(context, ASTnode, strict, ignoreNull) {\n  const isJSXValue = (node) => {\n    if (!node) {\n      return false;\n    }\n    switch (node.type) {\n      case 'ConditionalExpression':\n        if (strict) {\n          return isJSXValue(node.consequent) && isJSXValue(node.alternate);\n        }\n        return isJSXValue(node.consequent) || isJSXValue(node.alternate);\n      case 'LogicalExpression':\n        if (strict) {\n          return isJSXValue(node.left) && isJSXValue(node.right);\n        }\n        return isJSXValue(node.left) || isJSXValue(node.right);\n      case 'SequenceExpression':\n        return isJSXValue(node.expressions[node.expressions.length - 1]);\n      case 'JSXElement':\n      case 'JSXFragment':\n        return true;\n      case 'CallExpression':\n        return isCreateElement(context, node);\n      case 'Literal':\n        if (!ignoreNull && node.value === null) {\n          return true;\n        }\n        return false;\n      case 'Identifier': {\n        const variable = variableUtil.findVariableByName(context, node, node.name);\n        return isJSX(variable);\n      }\n      default:\n        return false;\n    }\n  };\n\n  let found = false;\n  astUtil.traverseReturns(ASTnode, context, (node, breakTraverse) => {\n    if (isJSXValue(node)) {\n      found = true;\n      breakTraverse();\n    }\n  });\n\n  return found;\n}\n\n/**\n * Check if the node is returning only null values\n *\n * @param {ASTNode} ASTnode The AST node being checked\n * @param {Context} context The context of `ASTNode`.\n * @returns {Boolean} True if the node is returning only null values\n */\nfunction isReturningOnlyNull(ASTnode, context) {\n  let found = false;\n  let foundSomethingElse = false;\n  astUtil.traverseReturns(ASTnode, context, (node) => {\n    // Traverse return statement\n    astUtil.traverse(node, {\n      enter(childNode) {\n        const setFound = () => {\n          found = true;\n          this.skip();\n        };\n        const setFoundSomethingElse = () => {\n          foundSomethingElse = true;\n          this.skip();\n        };\n        switch (childNode.type) {\n          case 'ReturnStatement':\n            break;\n          case 'ConditionalExpression':\n            if (childNode.consequent.value === null && childNode.alternate.value === null) {\n              setFound();\n            }\n            break;\n          case 'Literal':\n            if (childNode.value === null) {\n              setFound();\n            }\n            break;\n          default:\n            setFoundSomethingElse();\n        }\n      },\n    });\n  });\n\n  return found && !foundSomethingElse;\n}\n\nmodule.exports = {\n  isDOMComponent,\n  isFragment,\n  isJSX,\n  isJSXAttributeKey,\n  isWhiteSpaces,\n  isReturningJSX,\n  isReturningOnlyNull,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}