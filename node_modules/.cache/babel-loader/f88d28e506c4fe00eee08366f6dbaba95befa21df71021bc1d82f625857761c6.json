{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = extractValueFromTSNonNullExpression;\nvar extractValueFromThisExpression = require('./ThisExpression').default;\nvar extractValueFromCallExpression = require('./CallExpression').default;\nfunction navigate(obj, prop, value) {\n  if (value.computed) {\n    return value.optional ? obj + '?.[' + prop + ']' : obj + '[' + prop + ']';\n  }\n  return value.optional ? obj + '?.' + prop : obj + '.' + prop;\n}\n\n/**\n * Extractor function for a TSNonNullExpression type value node.\n * A TSNonNullExpression is accessing a TypeScript Non-Null Assertion\n * Operator !\n *\n * @param - value - AST Value object with type `TSNonNullExpression`\n * @returns - The extracted value converted to correct type\n *  and maintaing `obj.property` convention.\n */\nfunction extractValueFromTSNonNullExpression(value) {\n  // eslint-disable-next-line global-require\n  // const getValue = require('.').default;\n  var errorMessage = 'The prop value with an expression type of TSNonNullExpression could not be resolved. Please file an issue ( https://github.com/jsx-eslint/jsx-ast-utils/issues/new ) to get this fixed immediately.';\n\n  // it's just the name\n  if (value.type === 'Identifier') {\n    var name = value.name;\n    return name;\n  }\n  if (value.type === 'Literal') {\n    return value.value;\n  }\n  if (value.type === 'TSAsExpression') {\n    return extractValueFromTSNonNullExpression(value.expression);\n  }\n  if (value.type === 'CallExpression') {\n    return extractValueFromCallExpression(value);\n  }\n  if (value.type === 'ThisExpression') {\n    return extractValueFromThisExpression();\n  }\n\n  // does not contains properties & is not parenthesized\n  if (value.type === 'TSNonNullExpression' && (!value.extra || value.extra.parenthesized === false)) {\n    var expression = value.expression;\n    return extractValueFromTSNonNullExpression(expression) + '!';\n  }\n\n  // does not contains properties & is parenthesized\n  if (value.type === 'TSNonNullExpression' && value.extra && value.extra.parenthesized === true) {\n    var _expression = value.expression;\n    return '(' + extractValueFromTSNonNullExpression(_expression) + '!' + ')';\n  }\n  if (value.type === 'MemberExpression') {\n    // contains a property & is not parenthesized\n    if (!value.extra || value.extra.parenthesized === false) {\n      return navigate(extractValueFromTSNonNullExpression(value.object), extractValueFromTSNonNullExpression(value.property), value);\n    }\n\n    // contains a property & is parenthesized\n    if (value.extra && value.extra.parenthesized === true) {\n      var result = navigate(extractValueFromTSNonNullExpression(value.object), extractValueFromTSNonNullExpression(value.property), value);\n      return '(' + result + ')';\n    }\n  }\n\n  // try to fail silently, if specs for TSNonNullExpression change\n  // not throw, only log error. Similar to how it was done previously\n  if (value.expression) {\n    var _expression2 = value.expression;\n    while (_expression2) {\n      if (_expression2.type === 'Identifier') {\n        // eslint-disable-next-line no-console\n        console.error(errorMessage);\n        return _expression2.name;\n      }\n      var _expression3 = _expression2;\n      _expression2 = _expression3.expression;\n    }\n  }\n\n  // eslint-disable-next-line no-console\n  console.error(errorMessage);\n  return '';\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","extractValueFromTSNonNullExpression","extractValueFromThisExpression","require","extractValueFromCallExpression","navigate","obj","prop","computed","optional","errorMessage","type","name","expression","extra","parenthesized","_expression","object","property","result","_expression2","console","error","_expression3"],"sources":["/Users/goncaloarieiro/thesis/multimodal-interaction-app/node_modules/jsx-ast-utils/lib/values/expressions/TSNonNullExpression.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = extractValueFromTSNonNullExpression;\nvar extractValueFromThisExpression = require('./ThisExpression').default;\nvar extractValueFromCallExpression = require('./CallExpression').default;\n\nfunction navigate(obj, prop, value) {\n  if (value.computed) {\n    return value.optional ? obj + '?.[' + prop + ']' : obj + '[' + prop + ']';\n  }\n  return value.optional ? obj + '?.' + prop : obj + '.' + prop;\n}\n\n/**\n * Extractor function for a TSNonNullExpression type value node.\n * A TSNonNullExpression is accessing a TypeScript Non-Null Assertion\n * Operator !\n *\n * @param - value - AST Value object with type `TSNonNullExpression`\n * @returns - The extracted value converted to correct type\n *  and maintaing `obj.property` convention.\n */\nfunction extractValueFromTSNonNullExpression(value) {\n  // eslint-disable-next-line global-require\n  // const getValue = require('.').default;\n  var errorMessage = 'The prop value with an expression type of TSNonNullExpression could not be resolved. Please file an issue ( https://github.com/jsx-eslint/jsx-ast-utils/issues/new ) to get this fixed immediately.';\n\n  // it's just the name\n  if (value.type === 'Identifier') {\n    var name = value.name;\n\n    return name;\n  }\n\n  if (value.type === 'Literal') {\n    return value.value;\n  }\n\n  if (value.type === 'TSAsExpression') {\n    return extractValueFromTSNonNullExpression(value.expression);\n  }\n\n  if (value.type === 'CallExpression') {\n    return extractValueFromCallExpression(value);\n  }\n\n  if (value.type === 'ThisExpression') {\n    return extractValueFromThisExpression();\n  }\n\n  // does not contains properties & is not parenthesized\n  if (value.type === 'TSNonNullExpression' && (!value.extra || value.extra.parenthesized === false)) {\n    var expression = value.expression;\n\n    return extractValueFromTSNonNullExpression(expression) + '!';\n  }\n\n  // does not contains properties & is parenthesized\n  if (value.type === 'TSNonNullExpression' && value.extra && value.extra.parenthesized === true) {\n    var _expression = value.expression;\n\n    return '(' + extractValueFromTSNonNullExpression(_expression) + '!' + ')';\n  }\n\n  if (value.type === 'MemberExpression') {\n    // contains a property & is not parenthesized\n    if (!value.extra || value.extra.parenthesized === false) {\n      return navigate(extractValueFromTSNonNullExpression(value.object), extractValueFromTSNonNullExpression(value.property), value);\n    }\n\n    // contains a property & is parenthesized\n    if (value.extra && value.extra.parenthesized === true) {\n      var result = navigate(extractValueFromTSNonNullExpression(value.object), extractValueFromTSNonNullExpression(value.property), value);\n      return '(' + result + ')';\n    }\n  }\n\n  // try to fail silently, if specs for TSNonNullExpression change\n  // not throw, only log error. Similar to how it was done previously\n  if (value.expression) {\n    var _expression2 = value.expression;\n\n    while (_expression2) {\n      if (_expression2.type === 'Identifier') {\n        // eslint-disable-next-line no-console\n        console.error(errorMessage);\n        return _expression2.name;\n      }\n      var _expression3 = _expression2;\n      _expression2 = _expression3.expression;\n    }\n  }\n\n  // eslint-disable-next-line no-console\n  console.error(errorMessage);\n  return '';\n}"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,OAAO,GAAGC,mCAAmC;AACrD,IAAIC,8BAA8B,GAAGC,OAAO,CAAC,kBAAkB,CAAC,CAACH,OAAO;AACxE,IAAII,8BAA8B,GAAGD,OAAO,CAAC,kBAAkB,CAAC,CAACH,OAAO;AAExE,SAASK,QAAQA,CAACC,GAAG,EAAEC,IAAI,EAAER,KAAK,EAAE;EAClC,IAAIA,KAAK,CAACS,QAAQ,EAAE;IAClB,OAAOT,KAAK,CAACU,QAAQ,GAAGH,GAAG,GAAG,KAAK,GAAGC,IAAI,GAAG,GAAG,GAAGD,GAAG,GAAG,GAAG,GAAGC,IAAI,GAAG,GAAG;EAC3E;EACA,OAAOR,KAAK,CAACU,QAAQ,GAAGH,GAAG,GAAG,IAAI,GAAGC,IAAI,GAAGD,GAAG,GAAG,GAAG,GAAGC,IAAI;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASN,mCAAmCA,CAACF,KAAK,EAAE;EAClD;EACA;EACA,IAAIW,YAAY,GAAG,qMAAqM;;EAExN;EACA,IAAIX,KAAK,CAACY,IAAI,KAAK,YAAY,EAAE;IAC/B,IAAIC,IAAI,GAAGb,KAAK,CAACa,IAAI;IAErB,OAAOA,IAAI;EACb;EAEA,IAAIb,KAAK,CAACY,IAAI,KAAK,SAAS,EAAE;IAC5B,OAAOZ,KAAK,CAACA,KAAK;EACpB;EAEA,IAAIA,KAAK,CAACY,IAAI,KAAK,gBAAgB,EAAE;IACnC,OAAOV,mCAAmC,CAACF,KAAK,CAACc,UAAU,CAAC;EAC9D;EAEA,IAAId,KAAK,CAACY,IAAI,KAAK,gBAAgB,EAAE;IACnC,OAAOP,8BAA8B,CAACL,KAAK,CAAC;EAC9C;EAEA,IAAIA,KAAK,CAACY,IAAI,KAAK,gBAAgB,EAAE;IACnC,OAAOT,8BAA8B,CAAC,CAAC;EACzC;;EAEA;EACA,IAAIH,KAAK,CAACY,IAAI,KAAK,qBAAqB,KAAK,CAACZ,KAAK,CAACe,KAAK,IAAIf,KAAK,CAACe,KAAK,CAACC,aAAa,KAAK,KAAK,CAAC,EAAE;IACjG,IAAIF,UAAU,GAAGd,KAAK,CAACc,UAAU;IAEjC,OAAOZ,mCAAmC,CAACY,UAAU,CAAC,GAAG,GAAG;EAC9D;;EAEA;EACA,IAAId,KAAK,CAACY,IAAI,KAAK,qBAAqB,IAAIZ,KAAK,CAACe,KAAK,IAAIf,KAAK,CAACe,KAAK,CAACC,aAAa,KAAK,IAAI,EAAE;IAC7F,IAAIC,WAAW,GAAGjB,KAAK,CAACc,UAAU;IAElC,OAAO,GAAG,GAAGZ,mCAAmC,CAACe,WAAW,CAAC,GAAG,GAAG,GAAG,GAAG;EAC3E;EAEA,IAAIjB,KAAK,CAACY,IAAI,KAAK,kBAAkB,EAAE;IACrC;IACA,IAAI,CAACZ,KAAK,CAACe,KAAK,IAAIf,KAAK,CAACe,KAAK,CAACC,aAAa,KAAK,KAAK,EAAE;MACvD,OAAOV,QAAQ,CAACJ,mCAAmC,CAACF,KAAK,CAACkB,MAAM,CAAC,EAAEhB,mCAAmC,CAACF,KAAK,CAACmB,QAAQ,CAAC,EAAEnB,KAAK,CAAC;IAChI;;IAEA;IACA,IAAIA,KAAK,CAACe,KAAK,IAAIf,KAAK,CAACe,KAAK,CAACC,aAAa,KAAK,IAAI,EAAE;MACrD,IAAII,MAAM,GAAGd,QAAQ,CAACJ,mCAAmC,CAACF,KAAK,CAACkB,MAAM,CAAC,EAAEhB,mCAAmC,CAACF,KAAK,CAACmB,QAAQ,CAAC,EAAEnB,KAAK,CAAC;MACpI,OAAO,GAAG,GAAGoB,MAAM,GAAG,GAAG;IAC3B;EACF;;EAEA;EACA;EACA,IAAIpB,KAAK,CAACc,UAAU,EAAE;IACpB,IAAIO,YAAY,GAAGrB,KAAK,CAACc,UAAU;IAEnC,OAAOO,YAAY,EAAE;MACnB,IAAIA,YAAY,CAACT,IAAI,KAAK,YAAY,EAAE;QACtC;QACAU,OAAO,CAACC,KAAK,CAACZ,YAAY,CAAC;QAC3B,OAAOU,YAAY,CAACR,IAAI;MAC1B;MACA,IAAIW,YAAY,GAAGH,YAAY;MAC/BA,YAAY,GAAGG,YAAY,CAACV,UAAU;IACxC;EACF;;EAEA;EACAQ,OAAO,CAACC,KAAK,CAACZ,YAAY,CAAC;EAC3B,OAAO,EAAE;AACX","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}