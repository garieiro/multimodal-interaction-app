{"ast":null,"code":"const transformDataToSankeyChart = (data, expParam = null) => {\n  const nodesSet = new Set(); // Para evitar duplicatas\n  const formattedLinks = [];\n  if (expParam !== null) {\n    try {\n      const expIndex = parseInt(expParam, 10); // Converte o parâmetro para um inteiro\n\n      if (expIndex >= 0 && expIndex < data.length) {\n        const experience = data[expIndex];\n\n        // Extração de nós\n        for (const entry of experience) {\n          nodesSet.add(entry.Source);\n          nodesSet.add(entry.Target);\n        }\n        const nodesArray = Array.from(nodesSet);\n        const nodesIndex = Object.fromEntries(nodesArray.map((name, index) => [name, index]));\n\n        // Formatação dos nós\n        const formattedNodes = nodesArray.map(name => {\n          var _experience$find;\n          return {\n            name,\n            category: ((_experience$find = experience.find(entry => entry.Source === name || entry.Target === name)) === null || _experience$find === void 0 ? void 0 : _experience$find.Type) || 'default'\n          };\n        });\n\n        // Formatação dos links\n        for (const entry of experience) {\n          const sourceIndex = nodesIndex[entry.Source];\n          const targetIndex = nodesIndex[entry.Target];\n          const duration = calculateDuration(entry.Start, entry.End);\n          formattedLinks.push({\n            source: sourceIndex,\n            target: targetIndex,\n            value: duration\n          });\n        }\n        return {\n          nodes: formattedNodes,\n          links: formattedLinks\n        };\n      } else {\n        throw new Error(`Experience ${expParam} not found`);\n      }\n    } catch (error) {\n      return {\n        error: error.message,\n        status: 404\n      };\n    }\n  } else {\n    // Se nenhum parâmetro 'exp' for fornecido, retornar todos os dados necessários\n    for (const experience of data) {\n      for (const entry of experience) {\n        nodesSet.add(entry.Source);\n        nodesSet.add(entry.Target);\n      }\n    }\n    const nodesArray = Array.from(nodesSet);\n    const nodesIndex = Object.fromEntries(nodesArray.map((name, index) => [name, index]));\n    const formattedNodes = nodesArray.map(name => {\n      var _data$flat$find;\n      return {\n        name,\n        category: ((_data$flat$find = data.flat().find(entry => entry.Source === name || entry.Target === name)) === null || _data$flat$find === void 0 ? void 0 : _data$flat$find.Type) || 'default'\n      };\n    });\n    for (const experience of data) {\n      for (const entry of experience) {\n        const sourceIndex = nodesIndex[entry.Source];\n        const targetIndex = nodesIndex[entry.Target];\n        const duration = calculateDuration(entry.Start, entry.End);\n        formattedLinks.push({\n          source: sourceIndex,\n          target: targetIndex,\n          value: duration\n        });\n      }\n    }\n    return {\n      nodes: formattedNodes,\n      links: formattedLinks\n    };\n  }\n};\nexport default transformDataToSankeyChart;\n\n// Exemplo de uso\n// const sankeyData = transformDataToSankeyChart(data, expParam); // Passar 'data' e o 'expParam' aqui\n// console.log(sankeyData);","map":{"version":3,"names":["transformDataToSankeyChart","data","expParam","nodesSet","Set","formattedLinks","expIndex","parseInt","length","experience","entry","add","Source","Target","nodesArray","Array","from","nodesIndex","Object","fromEntries","map","name","index","formattedNodes","_experience$find","category","find","Type","sourceIndex","targetIndex","duration","calculateDuration","Start","End","push","source","target","value","nodes","links","Error","error","message","status","_data$flat$find","flat"],"sources":["/Users/goncaloarieiro/thesis/multimodal-interaction-app/src/components/charts/SankeyChart.js"],"sourcesContent":["const transformDataToSankeyChart = (data, expParam = null) => {\n  const nodesSet = new Set() // Para evitar duplicatas\n  const formattedLinks = []\n\n  if (expParam !== null) {\n    try {\n      const expIndex = parseInt(expParam, 10) // Converte o parâmetro para um inteiro\n\n      if (expIndex >= 0 && expIndex < data.length) {\n        const experience = data[expIndex]\n\n        // Extração de nós\n        for (const entry of experience) {\n          nodesSet.add(entry.Source)\n          nodesSet.add(entry.Target)\n        }\n\n        const nodesArray = Array.from(nodesSet)\n        const nodesIndex = Object.fromEntries(\n          nodesArray.map((name, index) => [name, index])\n        )\n\n        // Formatação dos nós\n        const formattedNodes = nodesArray.map((name) => ({\n          name,\n          category:\n            experience.find(\n              (entry) => entry.Source === name || entry.Target === name\n            )?.Type || 'default',\n        }))\n\n        // Formatação dos links\n        for (const entry of experience) {\n          const sourceIndex = nodesIndex[entry.Source]\n          const targetIndex = nodesIndex[entry.Target]\n          const duration = calculateDuration(entry.Start, entry.End)\n          formattedLinks.push({\n            source: sourceIndex,\n            target: targetIndex,\n            value: duration,\n          })\n        }\n\n        return {\n          nodes: formattedNodes,\n          links: formattedLinks,\n        }\n      } else {\n        throw new Error(`Experience ${expParam} not found`)\n      }\n    } catch (error) {\n      return {\n        error: error.message,\n        status: 404,\n      }\n    }\n  } else {\n    // Se nenhum parâmetro 'exp' for fornecido, retornar todos os dados necessários\n    for (const experience of data) {\n      for (const entry of experience) {\n        nodesSet.add(entry.Source)\n        nodesSet.add(entry.Target)\n      }\n    }\n\n    const nodesArray = Array.from(nodesSet)\n    const nodesIndex = Object.fromEntries(\n      nodesArray.map((name, index) => [name, index])\n    )\n\n    const formattedNodes = nodesArray.map((name) => ({\n      name,\n      category:\n        data\n          .flat()\n          .find((entry) => entry.Source === name || entry.Target === name)\n          ?.Type || 'default',\n    }))\n\n    for (const experience of data) {\n      for (const entry of experience) {\n        const sourceIndex = nodesIndex[entry.Source]\n        const targetIndex = nodesIndex[entry.Target]\n        const duration = calculateDuration(entry.Start, entry.End)\n        formattedLinks.push({\n          source: sourceIndex,\n          target: targetIndex,\n          value: duration,\n        })\n      }\n    }\n\n    return {\n      nodes: formattedNodes,\n      links: formattedLinks,\n    }\n  }\n}\n\nexport default transformDataToSankeyChart\n\n// Exemplo de uso\n// const sankeyData = transformDataToSankeyChart(data, expParam); // Passar 'data' e o 'expParam' aqui\n// console.log(sankeyData);\n"],"mappings":"AAAA,MAAMA,0BAA0B,GAAGA,CAACC,IAAI,EAAEC,QAAQ,GAAG,IAAI,KAAK;EAC5D,MAAMC,QAAQ,GAAG,IAAIC,GAAG,CAAC,CAAC,EAAC;EAC3B,MAAMC,cAAc,GAAG,EAAE;EAEzB,IAAIH,QAAQ,KAAK,IAAI,EAAE;IACrB,IAAI;MACF,MAAMI,QAAQ,GAAGC,QAAQ,CAACL,QAAQ,EAAE,EAAE,CAAC,EAAC;;MAExC,IAAII,QAAQ,IAAI,CAAC,IAAIA,QAAQ,GAAGL,IAAI,CAACO,MAAM,EAAE;QAC3C,MAAMC,UAAU,GAAGR,IAAI,CAACK,QAAQ,CAAC;;QAEjC;QACA,KAAK,MAAMI,KAAK,IAAID,UAAU,EAAE;UAC9BN,QAAQ,CAACQ,GAAG,CAACD,KAAK,CAACE,MAAM,CAAC;UAC1BT,QAAQ,CAACQ,GAAG,CAACD,KAAK,CAACG,MAAM,CAAC;QAC5B;QAEA,MAAMC,UAAU,GAAGC,KAAK,CAACC,IAAI,CAACb,QAAQ,CAAC;QACvC,MAAMc,UAAU,GAAGC,MAAM,CAACC,WAAW,CACnCL,UAAU,CAACM,GAAG,CAAC,CAACC,IAAI,EAAEC,KAAK,KAAK,CAACD,IAAI,EAAEC,KAAK,CAAC,CAC/C,CAAC;;QAED;QACA,MAAMC,cAAc,GAAGT,UAAU,CAACM,GAAG,CAAEC,IAAI;UAAA,IAAAG,gBAAA;UAAA,OAAM;YAC/CH,IAAI;YACJI,QAAQ,EACN,EAAAD,gBAAA,GAAAf,UAAU,CAACiB,IAAI,CACZhB,KAAK,IAAKA,KAAK,CAACE,MAAM,KAAKS,IAAI,IAAIX,KAAK,CAACG,MAAM,KAAKQ,IACvD,CAAC,cAAAG,gBAAA,uBAFDA,gBAAA,CAEGG,IAAI,KAAI;UACf,CAAC;QAAA,CAAC,CAAC;;QAEH;QACA,KAAK,MAAMjB,KAAK,IAAID,UAAU,EAAE;UAC9B,MAAMmB,WAAW,GAAGX,UAAU,CAACP,KAAK,CAACE,MAAM,CAAC;UAC5C,MAAMiB,WAAW,GAAGZ,UAAU,CAACP,KAAK,CAACG,MAAM,CAAC;UAC5C,MAAMiB,QAAQ,GAAGC,iBAAiB,CAACrB,KAAK,CAACsB,KAAK,EAAEtB,KAAK,CAACuB,GAAG,CAAC;UAC1D5B,cAAc,CAAC6B,IAAI,CAAC;YAClBC,MAAM,EAAEP,WAAW;YACnBQ,MAAM,EAAEP,WAAW;YACnBQ,KAAK,EAAEP;UACT,CAAC,CAAC;QACJ;QAEA,OAAO;UACLQ,KAAK,EAAEf,cAAc;UACrBgB,KAAK,EAAElC;QACT,CAAC;MACH,CAAC,MAAM;QACL,MAAM,IAAImC,KAAK,CAAC,cAActC,QAAQ,YAAY,CAAC;MACrD;IACF,CAAC,CAAC,OAAOuC,KAAK,EAAE;MACd,OAAO;QACLA,KAAK,EAAEA,KAAK,CAACC,OAAO;QACpBC,MAAM,EAAE;MACV,CAAC;IACH;EACF,CAAC,MAAM;IACL;IACA,KAAK,MAAMlC,UAAU,IAAIR,IAAI,EAAE;MAC7B,KAAK,MAAMS,KAAK,IAAID,UAAU,EAAE;QAC9BN,QAAQ,CAACQ,GAAG,CAACD,KAAK,CAACE,MAAM,CAAC;QAC1BT,QAAQ,CAACQ,GAAG,CAACD,KAAK,CAACG,MAAM,CAAC;MAC5B;IACF;IAEA,MAAMC,UAAU,GAAGC,KAAK,CAACC,IAAI,CAACb,QAAQ,CAAC;IACvC,MAAMc,UAAU,GAAGC,MAAM,CAACC,WAAW,CACnCL,UAAU,CAACM,GAAG,CAAC,CAACC,IAAI,EAAEC,KAAK,KAAK,CAACD,IAAI,EAAEC,KAAK,CAAC,CAC/C,CAAC;IAED,MAAMC,cAAc,GAAGT,UAAU,CAACM,GAAG,CAAEC,IAAI;MAAA,IAAAuB,eAAA;MAAA,OAAM;QAC/CvB,IAAI;QACJI,QAAQ,EACN,EAAAmB,eAAA,GAAA3C,IAAI,CACD4C,IAAI,CAAC,CAAC,CACNnB,IAAI,CAAEhB,KAAK,IAAKA,KAAK,CAACE,MAAM,KAAKS,IAAI,IAAIX,KAAK,CAACG,MAAM,KAAKQ,IAAI,CAAC,cAAAuB,eAAA,uBAFlEA,eAAA,CAGIjB,IAAI,KAAI;MAChB,CAAC;IAAA,CAAC,CAAC;IAEH,KAAK,MAAMlB,UAAU,IAAIR,IAAI,EAAE;MAC7B,KAAK,MAAMS,KAAK,IAAID,UAAU,EAAE;QAC9B,MAAMmB,WAAW,GAAGX,UAAU,CAACP,KAAK,CAACE,MAAM,CAAC;QAC5C,MAAMiB,WAAW,GAAGZ,UAAU,CAACP,KAAK,CAACG,MAAM,CAAC;QAC5C,MAAMiB,QAAQ,GAAGC,iBAAiB,CAACrB,KAAK,CAACsB,KAAK,EAAEtB,KAAK,CAACuB,GAAG,CAAC;QAC1D5B,cAAc,CAAC6B,IAAI,CAAC;UAClBC,MAAM,EAAEP,WAAW;UACnBQ,MAAM,EAAEP,WAAW;UACnBQ,KAAK,EAAEP;QACT,CAAC,CAAC;MACJ;IACF;IAEA,OAAO;MACLQ,KAAK,EAAEf,cAAc;MACrBgB,KAAK,EAAElC;IACT,CAAC;EACH;AACF,CAAC;AAED,eAAeL,0BAA0B;;AAEzC;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}