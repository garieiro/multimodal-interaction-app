{"ast":null,"code":"const transformDataToSankeyChart = data => {\n  const nodes = [];\n  const links = [];\n  const nodeNames = new Set(); // Para garantir que não haja nós duplicados\n  const valueMap = new Map(); // Para armazenar o valor por links\n\n  // Mapeia os eventos em nós e links\n  Object.values(data).forEach(eventGroup => {\n    eventGroup.forEach(event => {\n      const {\n        Source,\n        Target,\n        Duration\n      } = event; // Extraímos Source, Target e Duration\n\n      // Adiciona os nós se ainda não estiverem na lista\n      if (!nodeNames.has(Source)) {\n        nodes.push({\n          name: Source,\n          category: 'INPUT'\n        }); // Modifique a categoria conforme necessário\n        nodeNames.add(Source);\n      }\n      if (!nodeNames.has(Target)) {\n        nodes.push({\n          name: Target,\n          category: 'OUTPUT'\n        }); // Modifique a categoria conforme necessário\n        nodeNames.add(Target);\n      }\n\n      // Cria uma chave única para o link\n      const linkKey = `${Source} → ${Target}`;\n\n      // Se o link já existe, incrementa o valor do tempo\n      if (!valueMap.has(linkKey)) {\n        valueMap.set(linkKey, 0);\n      }\n      valueMap.set(linkKey, valueMap.get(linkKey) + Duration); // Soma a duração para o link\n    });\n  });\n\n  // Constrói a lista de links com valores dinâmicos\n  valueMap.forEach((value, key) => {\n    const [sourceName, targetName] = key.split(' → ');\n    const sourceIndex = nodes.findIndex(node => node.name === sourceName);\n    const targetIndex = nodes.findIndex(node => node.name === targetName);\n\n    // Verifica se o índice do nó fonte e do nó alvo são válidos\n    if (sourceIndex === -1) {\n      console.error(`Fonte não encontrada: ${sourceName}`);\n      return; // Ignora esse link se a fonte não for encontrada\n    }\n    if (targetIndex === -1) {\n      console.error(`Alvo não encontrado: ${targetName}`);\n      return; // Ignora esse link se o alvo não for encontrado\n    }\n    links.push({\n      source: sourceIndex,\n      target: targetIndex,\n      value: value // Usamos o tempo acumulado\n    });\n  });\n\n  // Retorna um único objeto com links e nodes\n  return {\n    links,\n    nodes\n  };\n};\nexport default transformDataToSankeyChart;","map":{"version":3,"names":["transformDataToSankeyChart","data","nodes","links","nodeNames","Set","valueMap","Map","Object","values","forEach","eventGroup","event","Source","Target","Duration","has","push","name","category","add","linkKey","set","get","value","key","sourceName","targetName","split","sourceIndex","findIndex","node","targetIndex","console","error","source","target"],"sources":["/Users/goncaloarieiro/thesis/multimodal-interaction-app/src/TransformDate/transformDataToSankeyChart.js"],"sourcesContent":["const transformDataToSankeyChart = (data) => {\n  const nodes = []\n  const links = []\n  const nodeNames = new Set() // Para garantir que não haja nós duplicados\n  const valueMap = new Map() // Para armazenar o valor por links\n\n  // Mapeia os eventos em nós e links\n  Object.values(data).forEach((eventGroup) => {\n    eventGroup.forEach((event) => {\n      const { Source, Target, Duration } = event // Extraímos Source, Target e Duration\n\n      // Adiciona os nós se ainda não estiverem na lista\n      if (!nodeNames.has(Source)) {\n        nodes.push({ name: Source, category: 'INPUT' }) // Modifique a categoria conforme necessário\n        nodeNames.add(Source)\n      }\n\n      if (!nodeNames.has(Target)) {\n        nodes.push({ name: Target, category: 'OUTPUT' }) // Modifique a categoria conforme necessário\n        nodeNames.add(Target)\n      }\n\n      // Cria uma chave única para o link\n      const linkKey = `${Source} → ${Target}`\n\n      // Se o link já existe, incrementa o valor do tempo\n      if (!valueMap.has(linkKey)) {\n        valueMap.set(linkKey, 0)\n      }\n      valueMap.set(linkKey, valueMap.get(linkKey) + Duration) // Soma a duração para o link\n    })\n  })\n\n  // Constrói a lista de links com valores dinâmicos\n  valueMap.forEach((value, key) => {\n    const [sourceName, targetName] = key.split(' → ')\n\n    const sourceIndex = nodes.findIndex((node) => node.name === sourceName)\n    const targetIndex = nodes.findIndex((node) => node.name === targetName)\n\n    // Verifica se o índice do nó fonte e do nó alvo são válidos\n    if (sourceIndex === -1) {\n      console.error(`Fonte não encontrada: ${sourceName}`)\n      return // Ignora esse link se a fonte não for encontrada\n    }\n\n    if (targetIndex === -1) {\n      console.error(`Alvo não encontrado: ${targetName}`)\n      return // Ignora esse link se o alvo não for encontrado\n    }\n\n    links.push({\n      source: sourceIndex,\n      target: targetIndex,\n      value: value, // Usamos o tempo acumulado\n    })\n  })\n\n  // Retorna um único objeto com links e nodes\n  return {\n    links,\n    nodes,\n  }\n}\n\nexport default transformDataToSankeyChart\n"],"mappings":"AAAA,MAAMA,0BAA0B,GAAIC,IAAI,IAAK;EAC3C,MAAMC,KAAK,GAAG,EAAE;EAChB,MAAMC,KAAK,GAAG,EAAE;EAChB,MAAMC,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC,EAAC;EAC5B,MAAMC,QAAQ,GAAG,IAAIC,GAAG,CAAC,CAAC,EAAC;;EAE3B;EACAC,MAAM,CAACC,MAAM,CAACR,IAAI,CAAC,CAACS,OAAO,CAAEC,UAAU,IAAK;IAC1CA,UAAU,CAACD,OAAO,CAAEE,KAAK,IAAK;MAC5B,MAAM;QAAEC,MAAM;QAAEC,MAAM;QAAEC;MAAS,CAAC,GAAGH,KAAK,EAAC;;MAE3C;MACA,IAAI,CAACR,SAAS,CAACY,GAAG,CAACH,MAAM,CAAC,EAAE;QAC1BX,KAAK,CAACe,IAAI,CAAC;UAAEC,IAAI,EAAEL,MAAM;UAAEM,QAAQ,EAAE;QAAQ,CAAC,CAAC,EAAC;QAChDf,SAAS,CAACgB,GAAG,CAACP,MAAM,CAAC;MACvB;MAEA,IAAI,CAACT,SAAS,CAACY,GAAG,CAACF,MAAM,CAAC,EAAE;QAC1BZ,KAAK,CAACe,IAAI,CAAC;UAAEC,IAAI,EAAEJ,MAAM;UAAEK,QAAQ,EAAE;QAAS,CAAC,CAAC,EAAC;QACjDf,SAAS,CAACgB,GAAG,CAACN,MAAM,CAAC;MACvB;;MAEA;MACA,MAAMO,OAAO,GAAG,GAAGR,MAAM,MAAMC,MAAM,EAAE;;MAEvC;MACA,IAAI,CAACR,QAAQ,CAACU,GAAG,CAACK,OAAO,CAAC,EAAE;QAC1Bf,QAAQ,CAACgB,GAAG,CAACD,OAAO,EAAE,CAAC,CAAC;MAC1B;MACAf,QAAQ,CAACgB,GAAG,CAACD,OAAO,EAAEf,QAAQ,CAACiB,GAAG,CAACF,OAAO,CAAC,GAAGN,QAAQ,CAAC,EAAC;IAC1D,CAAC,CAAC;EACJ,CAAC,CAAC;;EAEF;EACAT,QAAQ,CAACI,OAAO,CAAC,CAACc,KAAK,EAAEC,GAAG,KAAK;IAC/B,MAAM,CAACC,UAAU,EAAEC,UAAU,CAAC,GAAGF,GAAG,CAACG,KAAK,CAAC,KAAK,CAAC;IAEjD,MAAMC,WAAW,GAAG3B,KAAK,CAAC4B,SAAS,CAAEC,IAAI,IAAKA,IAAI,CAACb,IAAI,KAAKQ,UAAU,CAAC;IACvE,MAAMM,WAAW,GAAG9B,KAAK,CAAC4B,SAAS,CAAEC,IAAI,IAAKA,IAAI,CAACb,IAAI,KAAKS,UAAU,CAAC;;IAEvE;IACA,IAAIE,WAAW,KAAK,CAAC,CAAC,EAAE;MACtBI,OAAO,CAACC,KAAK,CAAC,yBAAyBR,UAAU,EAAE,CAAC;MACpD,OAAM,CAAC;IACT;IAEA,IAAIM,WAAW,KAAK,CAAC,CAAC,EAAE;MACtBC,OAAO,CAACC,KAAK,CAAC,wBAAwBP,UAAU,EAAE,CAAC;MACnD,OAAM,CAAC;IACT;IAEAxB,KAAK,CAACc,IAAI,CAAC;MACTkB,MAAM,EAAEN,WAAW;MACnBO,MAAM,EAAEJ,WAAW;MACnBR,KAAK,EAAEA,KAAK,CAAE;IAChB,CAAC,CAAC;EACJ,CAAC,CAAC;;EAEF;EACA,OAAO;IACLrB,KAAK;IACLD;EACF,CAAC;AACH,CAAC;AAED,eAAeF,0BAA0B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}