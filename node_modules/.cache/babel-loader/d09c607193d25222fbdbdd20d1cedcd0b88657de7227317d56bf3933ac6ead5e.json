{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nexports.default = getValue;\nexports.getLiteralValue = getLiteralValue;\nvar _Literal = require('./Literal');\nvar _Literal2 = _interopRequireDefault(_Literal);\nvar _JSXElement = require('./JSXElement');\nvar _JSXElement2 = _interopRequireDefault(_JSXElement);\nvar _JSXText = require('./JSXText');\nvar _JSXText2 = _interopRequireDefault(_JSXText);\nvar _JSXFragment = require('./JSXFragment');\nvar _JSXFragment2 = _interopRequireDefault(_JSXFragment);\nvar _expressions = require('./expressions');\nvar _expressions2 = _interopRequireDefault(_expressions);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n// Composition map of types to their extractor functions.\nvar TYPES = {\n  Literal: _Literal2.default,\n  JSXElement: _JSXElement2.default,\n  JSXExpressionContainer: _expressions2.default,\n  JSXText: _JSXText2.default,\n  JSXFragment: _JSXFragment2.default\n};\n\n// Composition map of types to their extractor functions to handle literals.\nvar LITERAL_TYPES = _extends({}, TYPES, {\n  JSXElement: function JSXElement() {\n    return null;\n  },\n  JSXExpressionContainer: _expressions.extractLiteral\n});\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *all* possible types.\n *\n * @param value - AST Value object on a JSX Attribute.\n */\nfunction getValue(value) {\n  if (!TYPES[value.type]) console.log(value.type);\n  return TYPES[value.type](value);\n}\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *some* possible types that map to literals.\n *\n * @param value - AST Value object on a JSX Attribute.\n */\nfunction getLiteralValue(value) {\n  return LITERAL_TYPES[value.type](value);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","default","getValue","getLiteralValue","_Literal","require","_Literal2","_interopRequireDefault","_JSXElement","_JSXElement2","_JSXText","_JSXText2","_JSXFragment","_JSXFragment2","_expressions","_expressions2","obj","__esModule","TYPES","Literal","JSXElement","JSXExpressionContainer","JSXText","JSXFragment","LITERAL_TYPES","extractLiteral","type","console","log"],"sources":["/Users/goncaloarieiro/thesis/multimodal-interaction-app/node_modules/jsx-ast-utils/lib/values/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = getValue;\nexports.getLiteralValue = getLiteralValue;\n\nvar _Literal = require('./Literal');\n\nvar _Literal2 = _interopRequireDefault(_Literal);\n\nvar _JSXElement = require('./JSXElement');\n\nvar _JSXElement2 = _interopRequireDefault(_JSXElement);\n\nvar _JSXText = require('./JSXText');\n\nvar _JSXText2 = _interopRequireDefault(_JSXText);\n\nvar _JSXFragment = require('./JSXFragment');\n\nvar _JSXFragment2 = _interopRequireDefault(_JSXFragment);\n\nvar _expressions = require('./expressions');\n\nvar _expressions2 = _interopRequireDefault(_expressions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Composition map of types to their extractor functions.\nvar TYPES = {\n  Literal: _Literal2.default,\n  JSXElement: _JSXElement2.default,\n  JSXExpressionContainer: _expressions2.default,\n  JSXText: _JSXText2.default,\n  JSXFragment: _JSXFragment2.default\n};\n\n// Composition map of types to their extractor functions to handle literals.\nvar LITERAL_TYPES = _extends({}, TYPES, {\n  JSXElement: function JSXElement() {\n    return null;\n  },\n  JSXExpressionContainer: _expressions.extractLiteral\n});\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *all* possible types.\n *\n * @param value - AST Value object on a JSX Attribute.\n */\nfunction getValue(value) {\n  if (!TYPES[value.type]) console.log(value.type);\n  return TYPES[value.type](value);\n}\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *some* possible types that map to literals.\n *\n * @param value - AST Value object on a JSX Attribute.\n */\nfunction getLiteralValue(value) {\n  return LITERAL_TYPES[value.type](value);\n}"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AAEF,IAAIC,QAAQ,GAAGJ,MAAM,CAACK,MAAM,IAAI,UAAUC,MAAM,EAAE;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;IAAE,IAAIG,MAAM,GAAGF,SAAS,CAACD,CAAC,CAAC;IAAE,KAAK,IAAII,GAAG,IAAID,MAAM,EAAE;MAAE,IAAIV,MAAM,CAACY,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,MAAM,EAAEC,GAAG,CAAC,EAAE;QAAEL,MAAM,CAACK,GAAG,CAAC,GAAGD,MAAM,CAACC,GAAG,CAAC;MAAE;IAAE;EAAE;EAAE,OAAOL,MAAM;AAAE,CAAC;AAEhQJ,OAAO,CAACa,OAAO,GAAGC,QAAQ;AAC1Bd,OAAO,CAACe,eAAe,GAAGA,eAAe;AAEzC,IAAIC,QAAQ,GAAGC,OAAO,CAAC,WAAW,CAAC;AAEnC,IAAIC,SAAS,GAAGC,sBAAsB,CAACH,QAAQ,CAAC;AAEhD,IAAII,WAAW,GAAGH,OAAO,CAAC,cAAc,CAAC;AAEzC,IAAII,YAAY,GAAGF,sBAAsB,CAACC,WAAW,CAAC;AAEtD,IAAIE,QAAQ,GAAGL,OAAO,CAAC,WAAW,CAAC;AAEnC,IAAIM,SAAS,GAAGJ,sBAAsB,CAACG,QAAQ,CAAC;AAEhD,IAAIE,YAAY,GAAGP,OAAO,CAAC,eAAe,CAAC;AAE3C,IAAIQ,aAAa,GAAGN,sBAAsB,CAACK,YAAY,CAAC;AAExD,IAAIE,YAAY,GAAGT,OAAO,CAAC,eAAe,CAAC;AAE3C,IAAIU,aAAa,GAAGR,sBAAsB,CAACO,YAAY,CAAC;AAExD,SAASP,sBAAsBA,CAACS,GAAG,EAAE;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAGD,GAAG,GAAG;IAAEf,OAAO,EAAEe;EAAI,CAAC;AAAE;;AAE9F;AACA,IAAIE,KAAK,GAAG;EACVC,OAAO,EAAEb,SAAS,CAACL,OAAO;EAC1BmB,UAAU,EAAEX,YAAY,CAACR,OAAO;EAChCoB,sBAAsB,EAAEN,aAAa,CAACd,OAAO;EAC7CqB,OAAO,EAAEX,SAAS,CAACV,OAAO;EAC1BsB,WAAW,EAAEV,aAAa,CAACZ;AAC7B,CAAC;;AAED;AACA,IAAIuB,aAAa,GAAGlC,QAAQ,CAAC,CAAC,CAAC,EAAE4B,KAAK,EAAE;EACtCE,UAAU,EAAE,SAASA,UAAUA,CAAA,EAAG;IAChC,OAAO,IAAI;EACb,CAAC;EACDC,sBAAsB,EAAEP,YAAY,CAACW;AACvC,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASvB,QAAQA,CAACb,KAAK,EAAE;EACvB,IAAI,CAAC6B,KAAK,CAAC7B,KAAK,CAACqC,IAAI,CAAC,EAAEC,OAAO,CAACC,GAAG,CAACvC,KAAK,CAACqC,IAAI,CAAC;EAC/C,OAAOR,KAAK,CAAC7B,KAAK,CAACqC,IAAI,CAAC,CAACrC,KAAK,CAAC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASc,eAAeA,CAACd,KAAK,EAAE;EAC9B,OAAOmC,aAAa,CAACnC,KAAK,CAACqC,IAAI,CAAC,CAACrC,KAAK,CAAC;AACzC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}