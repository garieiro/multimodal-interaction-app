{"ast":null,"code":"const transformDataToSankeyChart = data => {\n  const nodes = [];\n  const links = [];\n  const nodeNames = new Set(); // Para garantir que não haja nós duplicados\n  const valueMap = new Map(); // Para armazenar a soma de valores por links\n\n  // Mapeia os eventos em nós e links\n  Object.values(data).forEach(eventGroup => {\n    eventGroup.forEach(event => {\n      const {\n        Source,\n        Target\n      } = event; // Extraímos apenas o Source e Target\n\n      // Adiciona os nós se ainda não estiverem na lista\n      if (!nodeNames.has(Source)) {\n        nodes.push({\n          name: Source,\n          category: 'INPUT'\n        }); // Modifique a categoria conforme necessário\n        nodeNames.add(Source);\n      }\n      if (!nodeNames.has(Target)) {\n        nodes.push({\n          name: Target,\n          category: 'OUTPUT'\n        }); // Modifique a categoria conforme necessário\n        nodeNames.add(Target);\n      }\n\n      // Cria uma chave única para o link\n      const linkKey = `${Source} → ${Target}`;\n      // Incrementa o valor dinâmico para o link\n      if (!valueMap.has(linkKey)) {\n        valueMap.set(linkKey, 0);\n      }\n      valueMap.set(linkKey, valueMap.get(linkKey) + 1); // Incrementa o valor por cada ocorrência\n    });\n  });\n\n  // Constrói a lista de links com valores dinâmicos\n  valueMap.forEach((value, key) => {\n    const [sourceName, targetName] = key.split(' → ');\n    links.push({\n      source: nodes.findIndex(node => node.name === sourceName),\n      target: nodes.findIndex(node => node.name === targetName),\n      value: value // Usamos o valor dinâmico acumulado\n    });\n  });\n\n  // Retorna a estrutura de dados esperada para o gráfico de Sankey\n  return {\n    nodes,\n    links\n  };\n};\nexport default transformDataToSankeyChart;","map":{"version":3,"names":["transformDataToSankeyChart","data","nodes","links","nodeNames","Set","valueMap","Map","Object","values","forEach","eventGroup","event","Source","Target","has","push","name","category","add","linkKey","set","get","value","key","sourceName","targetName","split","source","findIndex","node","target"],"sources":["/Users/goncaloarieiro/thesis/multimodal-interaction-app/src/TransformDate/transformDataToSankeyChart.js"],"sourcesContent":["const transformDataToSankeyChart = (data) => {\n  const nodes = []\n  const links = []\n  const nodeNames = new Set() // Para garantir que não haja nós duplicados\n  const valueMap = new Map() // Para armazenar a soma de valores por links\n\n  // Mapeia os eventos em nós e links\n  Object.values(data).forEach((eventGroup) => {\n    eventGroup.forEach((event) => {\n      const { Source, Target } = event // Extraímos apenas o Source e Target\n\n      // Adiciona os nós se ainda não estiverem na lista\n      if (!nodeNames.has(Source)) {\n        nodes.push({ name: Source, category: 'INPUT' }) // Modifique a categoria conforme necessário\n        nodeNames.add(Source)\n      }\n\n      if (!nodeNames.has(Target)) {\n        nodes.push({ name: Target, category: 'OUTPUT' }) // Modifique a categoria conforme necessário\n        nodeNames.add(Target)\n      }\n\n      // Cria uma chave única para o link\n      const linkKey = `${Source} → ${Target}`\n      // Incrementa o valor dinâmico para o link\n      if (!valueMap.has(linkKey)) {\n        valueMap.set(linkKey, 0)\n      }\n      valueMap.set(linkKey, valueMap.get(linkKey) + 1) // Incrementa o valor por cada ocorrência\n    })\n  })\n\n  // Constrói a lista de links com valores dinâmicos\n  valueMap.forEach((value, key) => {\n    const [sourceName, targetName] = key.split(' → ')\n\n    links.push({\n      source: nodes.findIndex((node) => node.name === sourceName),\n      target: nodes.findIndex((node) => node.name === targetName),\n      value: value, // Usamos o valor dinâmico acumulado\n    })\n  })\n\n  // Retorna a estrutura de dados esperada para o gráfico de Sankey\n  return {\n    nodes,\n    links,\n  }\n}\n\nexport default transformDataToSankeyChart\n"],"mappings":"AAAA,MAAMA,0BAA0B,GAAIC,IAAI,IAAK;EAC3C,MAAMC,KAAK,GAAG,EAAE;EAChB,MAAMC,KAAK,GAAG,EAAE;EAChB,MAAMC,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC,EAAC;EAC5B,MAAMC,QAAQ,GAAG,IAAIC,GAAG,CAAC,CAAC,EAAC;;EAE3B;EACAC,MAAM,CAACC,MAAM,CAACR,IAAI,CAAC,CAACS,OAAO,CAAEC,UAAU,IAAK;IAC1CA,UAAU,CAACD,OAAO,CAAEE,KAAK,IAAK;MAC5B,MAAM;QAAEC,MAAM;QAAEC;MAAO,CAAC,GAAGF,KAAK,EAAC;;MAEjC;MACA,IAAI,CAACR,SAAS,CAACW,GAAG,CAACF,MAAM,CAAC,EAAE;QAC1BX,KAAK,CAACc,IAAI,CAAC;UAAEC,IAAI,EAAEJ,MAAM;UAAEK,QAAQ,EAAE;QAAQ,CAAC,CAAC,EAAC;QAChDd,SAAS,CAACe,GAAG,CAACN,MAAM,CAAC;MACvB;MAEA,IAAI,CAACT,SAAS,CAACW,GAAG,CAACD,MAAM,CAAC,EAAE;QAC1BZ,KAAK,CAACc,IAAI,CAAC;UAAEC,IAAI,EAAEH,MAAM;UAAEI,QAAQ,EAAE;QAAS,CAAC,CAAC,EAAC;QACjDd,SAAS,CAACe,GAAG,CAACL,MAAM,CAAC;MACvB;;MAEA;MACA,MAAMM,OAAO,GAAG,GAAGP,MAAM,MAAMC,MAAM,EAAE;MACvC;MACA,IAAI,CAACR,QAAQ,CAACS,GAAG,CAACK,OAAO,CAAC,EAAE;QAC1Bd,QAAQ,CAACe,GAAG,CAACD,OAAO,EAAE,CAAC,CAAC;MAC1B;MACAd,QAAQ,CAACe,GAAG,CAACD,OAAO,EAAEd,QAAQ,CAACgB,GAAG,CAACF,OAAO,CAAC,GAAG,CAAC,CAAC,EAAC;IACnD,CAAC,CAAC;EACJ,CAAC,CAAC;;EAEF;EACAd,QAAQ,CAACI,OAAO,CAAC,CAACa,KAAK,EAAEC,GAAG,KAAK;IAC/B,MAAM,CAACC,UAAU,EAAEC,UAAU,CAAC,GAAGF,GAAG,CAACG,KAAK,CAAC,KAAK,CAAC;IAEjDxB,KAAK,CAACa,IAAI,CAAC;MACTY,MAAM,EAAE1B,KAAK,CAAC2B,SAAS,CAAEC,IAAI,IAAKA,IAAI,CAACb,IAAI,KAAKQ,UAAU,CAAC;MAC3DM,MAAM,EAAE7B,KAAK,CAAC2B,SAAS,CAAEC,IAAI,IAAKA,IAAI,CAACb,IAAI,KAAKS,UAAU,CAAC;MAC3DH,KAAK,EAAEA,KAAK,CAAE;IAChB,CAAC,CAAC;EACJ,CAAC,CAAC;;EAEF;EACA,OAAO;IACLrB,KAAK;IACLC;EACF,CAAC;AACH,CAAC;AAED,eAAeH,0BAA0B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}